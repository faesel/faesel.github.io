{"componentChunkName":"component---src-templates-blog-js","path":"/blog/aspnet-graphql-server-with-hot-chocolate","result":{"data":{"site":{"siteMetadata":{"siteUrl":"https://www.faesel.com"}},"contentfulBlog":{"title":"ASP.NET GraphQL server with Hot Chocolate","slug":"aspnet-graphql-server-with-hot-chocolate","tags":["graphql","hotchocolate","graphql-voyager","asp.net","authentication","authorization","versioning","rest","chilli-cream","logging","open-telemetry","banana-cake-pop"],"hero":{"file":{"url":"//images.ctfassets.net/wjg1udsw901v/74JrRnpexhOnSAsBwNOPV7/635bc389cea0de36f3158df45483ae85/graphql.jpg"},"title":"GraphQL With Hot Chocolate"},"datePublished":"April 4th, 2021","iso8601DatePublished":"2021-04-04T23:00:00.000Z","bodym":{"childMarkdownRemark":{"excerpt":"Starting my journey with GraphQL Up till now, I've‚Ä¶","timeToRead":11,"html":"<h1 id=\"starting-my-journey-with-graphql\" style=\"position:relative;\"><a href=\"#starting-my-journey-with-graphql\" aria-label=\"starting my journey with graphql permalink\" class=\"auto-link-header before\"><svg aria-hidden=\"true\" height=\"40\" width=\"40\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Starting my journey with GraphQL</h1>\n<p>Up till now, I've always heavily relied on RESTfull services to power API's, this recently got widened with GRPC which you can read about in my article <a href=\"https://www.faesel.com/blog/dotnet-grpc-forgot-to-tell-you\" target=\"_blank\" rel=\"nofollow\">.NET &#x26; GRPC What they forgot to tell you</a>. GraphQL was the third final frontier that needed exploring ü•æ...until now.</p>\n<p>Having looked at it a year back the implementations for .NET were in their infancy, which meant that your server would only be as good as the framework you choose. Fast forward to 2021, <a href=\"https://github.com/ChilliCream/hotchocolate\" target=\"_blank\" rel=\"nofollow\">Chilli Creams Hotchocolate</a> has gained some serious ground and makes GraphQL an appealing proposition for developers.</p>\n<p>In this article I hope to cover two main points,</p>\n<ul>\n<li>How REST is designed to break backend engineers</li>\n<li>How GraphQL saves the day</li>\n</ul>\n<h1 id=\"your-typical-rest-scenario\" style=\"position:relative;\"><a href=\"#your-typical-rest-scenario\" aria-label=\"your typical rest scenario permalink\" class=\"auto-link-header before\"><svg aria-hidden=\"true\" height=\"40\" width=\"40\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Your typical REST scenario</h1>\n<p>Let's paint the scene, your a backend engineer who's creating an endpoint for showing a list of cats. With your battle-tested REST knowledge, you set out to create your first basic endpoint in the <code>CatsController</code> that returns all cats and the front end engineer is ready to integrate it into his UI.</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">// api/cats\n[HttpGet]\npublic async Task&lt;IActionResult&gt; GetCats()\n{\n    using (var context = contextFactory.CreateDbContext())\n    {\n        var cats = await context.Cats.ToListAsync();\n\n        if(cat != null)\n            return Ok(cats);\n    }\n\n    return NoContent();\n}</code>\n        </deckgo-highlight-code>\n      \n<p>The app soon becomes a hit! your product manager decides to expand the functionality to filter by cat descriptions and to create a new cat information page. Getting to work you expand the endpoints for the front end engineers to use.</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">//api/cats/1\n[HttpGet]\n[Route(&quot;{id}&quot;)]\npublic async Task&lt;IActionResult&gt; GetCatsById([FromRoute] int id)\n{\n    using (var context = contextFactory.CreateDbContext())\n    {\n        var cats = await context.Cats.FirstOrDefaultAsync(x =&gt; x.Id == id);\n\n        if(cats != null)\n            return Ok(cats);\n    }\n\n    return NoContent();\n}\n\n// api/cats/description/brown\n[HttpGet]\n[Route(&quot;description/{description}&quot;)]\npublic async Task&lt;IActionResult&gt; GetCatsByDescription([FromRoute] string description)\n{\n    using (var context = contextFactory.CreateDbContext())\n    {\n        var cats = await context.Cats.Where(x =&gt; x.Description.Contains(description)).ToListAsync();\n\n        if(cats != null)\n            return Ok(payload);\n    }\n\n    return NoContent();\n}</code>\n        </deckgo-highlight-code>\n      \n<p>The cycle continues with product owners coming up with more feature requests and at the bottom of the pile, you got the backend engineer being reactive to all the changes. By the time you've wrapped up the project your left with a code smell of 10+ endpoints üí©.</p>\n<p>The situation further degrades after a year when the UI gets redesigned and features are culled based on user usage. You end up with random floating endpoints because quite frankly no one audits their endpoints for dead code.</p>\n<p>This is where GraphQL steps in, it switches the responsibility of an engineer from anticipating and creating endpoints to simply upfront displaying everything that's available with declarative meaning.</p>\n<h1 id=\"hot-chocolate-net-graphql-server-framework\" style=\"position:relative;\"><a href=\"#hot-chocolate-net-graphql-server-framework\" aria-label=\"hot chocolate net graphql server framework permalink\" class=\"auto-link-header before\"><svg aria-hidden=\"true\" height=\"40\" width=\"40\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Hot Chocolate (.NET GraphQL server framework)</h1>\n<p>Hot chocolate is one of the leading implementations of a GraphQL server, one important thing to note when choosing a framework is that your implementation will only be as good as the framework you choose. As the <a href=\"http://spec.graphql.org/\" target=\"_blank\" rel=\"nofollow\">GraphQL specification</a> progresses you want a framework that keeps up to date with the changes... Hot Chocolate does that.</p>\n<p>To understand the basics of Hot Chocolate I recommend <a href=\"https://www.youtube.com/user/binarythistle\" target=\"_blank\" rel=\"nofollow\"><strong>Les Jackson's</strong></a> free course on youtube. It is a bit lengthy at 3 Hours and 45 Minutes but it allows you to create an ASP.NET implementation from scratch and understand basic concepts like Querys, Mutations and Subscriptions. By the end of the course, you have a GraphQL service that can do CRUD actions (do üëç his video it's great!).</p>\n<p><iframe width=\"100%\" height=\"315\" src=\"https://www.youtube-nocookie.com/embed/HuN94qNwQmM?rel=0\" frameBorder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowFullScreen></iframe></p>\n<p>The source code he produces can also be found on his <a href=\"https://github.com/binarythistle/S04E01---.NET-5-GraphQL-API\" target=\"_blank\" rel=\"nofollow\">github repo</a>. The source code is a great starting point as it creates a docker image containing an MSSQL database. The solution itself already has Entity Framework and Hot Chocolate bootstrapped, with two entities to test with.</p>\n<p>On top of this <a href=\"https://github.com/ChilliCream/hotchocolate/blob/main/src/BananaCakePop\" target=\"_blank\" rel=\"nofollow\">Banana Cake Pop üçå</a> is also integrated which allows you to query your server through a browser (similar to swagger).</p>\n<p>As well as <a href=\"https://github.com/APIs-guru/graphql-voyager\" target=\"_blank\" rel=\"nofollow\">GraphQL Voyager üöÄ</a> (do checkout the <a href=\"https://apis.guru/graphql-voyager/\" target=\"_blank\" rel=\"nofollow\">live demo</a>).</p>\n<p>To understand the remainder of the article it's important to have some basic knowledge of Hot Chocolate.</p>\n<h1 id=\"graphql-voyager\" style=\"position:relative;\"><a href=\"#graphql-voyager\" aria-label=\"graphql voyager permalink\" class=\"auto-link-header before\"><svg aria-hidden=\"true\" height=\"40\" width=\"40\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GraphQl Voyager</h1>\n<p>Whilst this is an addition to what's being discussed, it's worth briefly mentioning. Voyager helps facilitate the move of a backend engineer from creating and documenting prescriptive REST endpoints to simply becoming a harbour of documentation and entities.</p>\n<blockquote>\n<p>The marker of a quality API has shifted from creating a subjectively RESTfull API and how well it's documented to ... just how well it's documented üìù.</p>\n</blockquote>\n<p>Here's a taste of what is looks like for our API,</p>\n<p><img src=\"//images.ctfassets.net/wjg1udsw901v/8f7Kb65mDXS5ZBSA4At50/08bcdb6bfe661bdb50965e7b9e8d5a81/graphql-voyager.png\" alt=\"Graphql Voyager\"></p>\n<h1 id=\"what-they-forgot-to-mention\" style=\"position:relative;\"><a href=\"#what-they-forgot-to-mention\" aria-label=\"what they forgot to mention permalink\" class=\"auto-link-header before\"><svg aria-hidden=\"true\" height=\"40\" width=\"40\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>What they forgot to mention</h1>\n<p>Up till now what we have discussed fits the 80% CRUD usecase, however as we know API's that are in the wild also deal with a range of other responsibilities. The remainder of this article is to shed some light on how this is done.</p>\n<h2 id=\"how-to-version-your-api\" style=\"position:relative;\"><a href=\"#how-to-version-your-api\" aria-label=\"how to version your api permalink\" class=\"auto-link-header before\"><svg aria-hidden=\"true\" height=\"40\" width=\"40\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>How to version your API</h2>\n<p>The typical versioning strategy for REST is to version using URLs <code>https://api.cats.com/v1</code> (when developers can be bothered). However with GraphQL as your only ever posting to a single endpoint that strategy is no longer a prefered solution.</p>\n<blockquote>\n<p>While there's nothing that prevents a GraphQL service from being versioned just like any other REST API, GraphQL takes a strong opinion on avoiding versioning by providing the tools for the continuous evolution of a GraphQL schema.\n<em><a href=\"https://graphql.org/learn/best-practices/\" target=\"_blank\" rel=\"nofollow\">Taken from GraphQL Best Practices</a></em></p>\n</blockquote>\n<p>Before we begin on how to version, there are some distinct points to note.</p>\n<p>Non-breaking changes can continue as they would with REST, adding properties to entities (as you would with response models in REST), continues to be a way to evolve your API. Similarly adding new query types to your GraphQL server is also deemed as a non-breaking change, and is equivalent to adding new endpoints in REST.</p>\n<p>GraphQL aids in breaking changes caused due to nullability as <strong>everything</strong> unless specified is treated as nullable. This leads to upfront resilience on the front end to missing data, the <code>id: Int!</code> in the example below cannot be null.</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">type Cats {\n  id: Int!\n  name: String\n}</code>\n        </deckgo-highlight-code>\n      \n<p>Eventually, we do still hit circumstances where a breaking change is needed. In these situations we have two strategies. The first as <a href=\"https://chillicream.com/docs/hotchocolate/defining-a-schema/versioning/\" target=\"_blank\" rel=\"nofollow\">Chilli Cream Docs</a> specify is to add deprecated flags to old properties and begin to shift usage to new versions.</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">public class CatsType : ObjectType&lt;Cats&gt;\n{\n    protected override void Configure(IObjectTypeDescriptor&lt;Cats&gt; descriptor)\n    {\n        descriptor.Description(&quot;Represents commands available on a platform&quot;);\n\n        descriptor.Field(x =&gt; x.Name).Deprecated(&quot;This is no longer used, use FirstName and LastName&quot;);\n        descriptor.Field(x =&gt; x.FirstName);\n        descriptor.Field(x =&gt; x.LastName);\n    }\n}</code>\n        </deckgo-highlight-code>\n      \n<p>For client developers, this then creates warnings when using a deprecated property.</p>\n<p><img src=\"//images.ctfassets.net/wjg1udsw901v/2BkWWBcz1UAAU9fFVavBGQ/c812ee032ddcd8eb600b165616f68e5b/Screenshot_2021-03-26_153337.png\" alt=\"Depricated GraphQL property\"></p>\n<p>Whilst this approach works over time it could create a lot of noise if you have many deprecated properties, an alternative approach is to split the entity entirely, use different classes between the two versions. Here is an example, we start by creating two query types,</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">public record CatResponse1(int Id, string Name);\npublic record CatResponse2(int Id, string FirstName, string LastName);</code>\n        </deckgo-highlight-code>\n      \n<p>Both of these would contain their own Code First type files</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">public class CatType1 : ObjectType&lt;CatResponse1&gt;\n{\n    protected override void Configure(IObjectTypeDescriptor&lt;CatResponse1&gt; descriptor)\n    {\n        descriptor.Description(&quot;Represents cats!&quot;);\n\n        descriptor.Field(x =&gt; x.Name)\n            .Description(&quot;Represents the name of the cat&quot;)\n            .Deprecated(&quot;This is no longer used, use FirstName and LastName from Cat2&quot;);\n    }\n}\n\npublic class CatType2 : ObjectType&lt;CatResponse2&gt;\n{\n    protected override void Configure(IObjectTypeDescriptor&lt;CatResponse2&gt; descriptor)\n    {\n        descriptor.Description(&quot;Represents cats!&quot;);\n\n        descriptor.Field(x =&gt; x.FirstName)\n            .Description(&quot;Represents the name firstname of the cat&quot;);\n        descriptor.Field(x =&gt; x.LastName)\n            .Description(&quot;Represents the name lastname of the cat&quot;);\n    }\n}</code>\n        </deckgo-highlight-code>\n      \n<p>The final piece of code is to use the intermediary response models. Under the hood we are still using the same EF entity.</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">public class Query\n{\n    [UseDbContext(typeof(AppDbContext))]\n    [UseFiltering]\n    [UseSorting]\n    public IQueryable&lt;CatResponse1&gt; GetCat1([ScopedService] AppDbContext context)\n    {\n        var cats = context.Cats;\n\n        return cats.Select(x =&gt; new CatResponse1(x.Id, x.Name));\n    }\n\n    [UseDbContext(typeof(AppDbContext))]\n    [UseFiltering]\n    [UseSorting]\n    public IQueryable&lt;CatResponse2&gt; GetCat2([ScopedService] AppDbContext context)\n    {\n        var cats = context.Cats;\n\n        return cats.Select(x =&gt; new CatResponse2(x.Id, x.FirstName, x.LastName));\n    }\n}</code>\n        </deckgo-highlight-code>\n      \n<p>These changes now allow us to split our models, the two can be queried independently.</p>\n<p><img src=\"//images.ctfassets.net/wjg1udsw901v/4RSPAHISSIpKS3qFfZbRq1/b53386073d0e86bc0e14a95b30ff857a/versioned-entities.png\" alt=\"Versioned types\"></p>\n<h2 id=\"how-to-do-authentication\" style=\"position:relative;\"><a href=\"#how-to-do-authentication\" aria-label=\"how to do authentication permalink\" class=\"auto-link-header before\"><svg aria-hidden=\"true\" height=\"40\" width=\"40\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>How to do Authentication</h2>\n<p>Since Hot Chocolate works on top of ASP.NET we can leverage on all the traditional Authentication pipelines we use for REST, nothing changes! To demonstrate this I'm going to extend the base implementation with a basic authentication mechanism using a header value <code>x-api-key</code> and a key defined in the <code>appsettings.json</code>.</p>\n<h3 id=\"adding-key-based-authentication\" style=\"position:relative;\"><a href=\"#adding-key-based-authentication\" aria-label=\"adding key based authentication permalink\" class=\"auto-link-header before\"><svg aria-hidden=\"true\" height=\"40\" width=\"40\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Adding key-based authentication</h3>\n<p>To begin let's first add basic app settings to hold our authentication key (this represents the key the client will pass to the server to authentication their request), and create a class to deserialise into using <code>IOptions</code> interface.</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">//Code goes into appsettings.json\n&quot;AuthenticationSettings&quot;: {\n    &quot;AuthenticationToken&quot;: &quot;secret123&quot;\n}\n\n//New class to serialize into\npublic class AuthenticationSettings\n{\n    public string AuthenticationToken { get; set; }\n}\n\n//Register the configuration in Startup.cs &gt; ConfigureServices function\nservices.Configure&lt;AuthenticationSettings&gt;(Configuration.GetSection(nameof(AuthenticationSettings)));</code>\n        </deckgo-highlight-code>\n      \n<p>Next we will create authentication scheme options as follows,</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">public class ApiKeyAuthenticationOptions : AuthenticationSchemeOptions\n{\n    public const string DefaultScheme = &quot;KeyBasedScheme&quot;;\n    public string Scheme =&gt; DefaultScheme;\n    public string AuthenticationType = DefaultScheme;\n}</code>\n        </deckgo-highlight-code>\n      \n<p>The next part is where the crux of the code is, the <code>AuthenticationHandler</code> is what determines whether the request was correctly authenticated. On a successful attempt, it populates the ClaimsPrinciple.</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">public class ApiKeyAuthenticationHandler : AuthenticationHandler&lt;ApiKeyAuthenticationOptions&gt;\n{\n    private const string ProblemDetailsContentType = &quot;application/problem+json&quot;;\n    private const string AuthenticationHeaderName = &quot;x-api-key&quot;;\n    private readonly AuthenticationSettings AuthenticationSettings;\n\n    public ApiKeyAuthenticationHandler(\n        IOptionsMonitor&lt;ApiKeyAuthenticationOptions&gt; options,\n        ILoggerFactory logger,\n        UrlEncoder encoder,\n        ISystemClock clock,\n        IOptions&lt;AuthenticationSettings&gt; authenticationSettings) : base(options, logger, encoder, clock)\n    {\n        AuthenticationSettings = authenticationSettings.Value;\n    }\n\n    protected override Task&lt;AuthenticateResult&gt; HandleAuthenticateAsync()\n    {\n        if (!Request.Headers.TryGetValue(AuthenticationHeaderName, out var apiKeyHeaderValues))\n        {\n            return Task.FromResult(AuthenticateResult.NoResult());\n        }\n\n        var providedApiKey = apiKeyHeaderValues.FirstOrDefault();\n\n        if (apiKeyHeaderValues.Count == 0 || string.IsNullOrWhiteSpace(providedApiKey))\n        {\n            return Task.FromResult(AuthenticateResult.NoResult());\n        }\n\n        var isMatchingKey = providedApiKey.Equals(AuthenticationSettings.AuthenticationToken);\n\n        if (isMatchingKey)\n        {\n            var claims = new List&lt;Claim&gt; {\n                //Add your claims here\n            };\n            var identity = new ClaimsIdentity(claims, Options.AuthenticationType);\n            var identities = new List&lt;ClaimsIdentity&gt; { identity };\n            var principal = new ClaimsPrincipal(identities);\n            var ticket = new AuthenticationTicket(principal, Options.Scheme);\n\n            return Task.FromResult(AuthenticateResult.Success(ticket));\n        }\n\n        return Task.FromResult(AuthenticateResult.Fail(&quot;Invalid API Key provided.&quot;));\n    }\n\n    protected override async Task HandleChallengeAsync(AuthenticationProperties properties)\n    {\n        Response.StatusCode = (int)HttpStatusCode.Unauthorized;\n        Response.ContentType = ProblemDetailsContentType;\n        var problemDetails = new { Information = &quot;Unauthorized&quot; };\n\n        await Response.WriteAsync(JsonSerializer.Serialize(problemDetails));\n    }\n\n    protected override async Task HandleForbiddenAsync(AuthenticationProperties properties)\n    {\n        Response.StatusCode = (int)HttpStatusCode.Forbidden;\n        Response.ContentType = ProblemDetailsContentType;\n        var problemDetails = new { Information = &quot;Forbidden&quot; };\n\n        await Response.WriteAsync(JsonSerializer.Serialize(problemDetails));\n    }\n}</code>\n        </deckgo-highlight-code>\n      \n<p>The final part need is to register this in our startup class, below are the two bits of code needed. Once we have this in place the <code>[Authorize]</code> tag will work for regular REST requests, any request sent without an <code>x-api-key</code> value of 'secret123' will be rejected. The next step is to see how we replicate this in GraphQL.</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">public void ConfigureServices(IServiceCollection services)\n{\n    ...\n    services.AddAuthentication(options =&gt;\n    {\n        options.DefaultAuthenticateScheme = ApiKeyAuthenticationOptions.DefaultScheme;\n        options.DefaultChallengeScheme = ApiKeyAuthenticationOptions.DefaultScheme;\n    }).AddScheme&lt;ApiKeyAuthenticationOptions, ApiKeyAuthenticationHandler&gt;(\n        ApiKeyAuthenticationOptions.DefaultScheme,\n        null\n    );\n    services.AddAuthorization();\n}\n\npublic void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n{\n    ...\n    app.UseAuthentication();\n    app.UseAuthorization();\n}</code>\n        </deckgo-highlight-code>\n      \n<h3 id=\"authenticating-a-graphql-entity\" style=\"position:relative;\"><a href=\"#authenticating-a-graphql-entity\" aria-label=\"authenticating a graphql entity permalink\" class=\"auto-link-header before\"><svg aria-hidden=\"true\" height=\"40\" width=\"40\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Authenticating a GraphQl Entity</h3>\n<p>Authentication in GraphQL works by authorizing individual models, to begin we first need to add the HotChocolate Authorization package <code>HotChocolate.AspNetCore.Authorization</code> and enable it in the <code>Startup.cs</code> class, its a one-liner,</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">services.AddAuthorizeDirectiveType()</code>\n        </deckgo-highlight-code>\n      \n<p>Now similar to the <code>[Authorize]</code> tag we use for REST we can enable Authorization in for our individual ObjectTypes by adding a simple <code>descriptor.Authorize()</code> call.</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">public class CatType1 : ObjectType&lt;CatResponse1&gt;\n{\n    protected override void Configure(IObjectTypeDescriptor&lt;CatResponse1&gt; descriptor)\n    {\n        descriptor.Authorize();\n        ...\n    }\n}</code>\n        </deckgo-highlight-code>\n      \n<p>Once this has been added making calls without the header will return an unauthenticated result that looks like this,</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">{\n  &quot;errors&quot;: [\n    {\n      &quot;message&quot;: &quot;The current user is not authorized to access this resource.&quot;,\n      &quot;locations&quot;: [\n        {\n          &quot;line&quot;: 3,\n          &quot;column&quot;: 5\n        }\n      ],\n      &quot;path&quot;: [\n        &quot;cat1&quot;,\n        1,\n        &quot;id&quot;\n      ],\n      &quot;extensions&quot;: {\n        &quot;code&quot;: &quot;AUTH_NOT_AUTHENTICATED&quot;\n      }\n    },\n    ...</code>\n        </deckgo-highlight-code>\n      \n<h2 id=\"how-to-do-authorisation\" style=\"position:relative;\"><a href=\"#how-to-do-authorisation\" aria-label=\"how to do authorisation permalink\" class=\"auto-link-header before\"><svg aria-hidden=\"true\" height=\"40\" width=\"40\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>How to do Authorisation</h2>\n<p>Extending the code to work with Authorization is also a quick change, in this example we will authorize based on the user's role. To begin we will extend our <code>ApiKeyAuthenticationHandler</code> to populate a claim when the authentication key has matched,</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">var claims = new List&lt;Claim&gt; {\n    new Claim(&quot;http://schemas.microsoft.com/ws/2008/06/identity/claims/role&quot;, &quot;Admin&quot;)\n};</code>\n        </deckgo-highlight-code>\n      \n<p>Next we can pass a list of accepted roles into the ObjectType <code>CatType1</code>, in this example I have intentionally added a role that doesn't exist.</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">var roles = new string[] { &quot;NotAdmin&quot; };\ndescriptor.Authorize(roles);</code>\n        </deckgo-highlight-code>\n      \n<p>Making a request now will spark an unauthorized error,</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">{\n  &quot;errors&quot;: [\n    {\n      &quot;message&quot;: &quot;The current user is not authorized to access this resource.&quot;,\n      &quot;locations&quot;: [\n        {\n          &quot;line&quot;: 3,\n          &quot;column&quot;: 5\n        }\n      ],\n      &quot;path&quot;: [\n        &quot;cat1&quot;,\n        1,\n        &quot;id&quot;\n      ],\n      &quot;extensions&quot;: {\n        &quot;code&quot;: &quot;AUTH_NOT_AUTHORIZED&quot;\n      }\n    },\n    ...</code>\n        </deckgo-highlight-code>\n      \n<h2 id=\"how-does-logging-work\" style=\"position:relative;\"><a href=\"#how-does-logging-work\" aria-label=\"how does logging work permalink\" class=\"auto-link-header before\"><svg aria-hidden=\"true\" height=\"40\" width=\"40\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>How does logging work</h2>\n<p>Regarding logging Chilli Cream has created a guide to adding an <code>AddDiagnosticEventListener</code> that's able to trace incoming requests, check out the article <a href=\"https://chillicream.com/blog/2021/01/10/hot-chocolate-logging\" target=\"_blank\" rel=\"nofollow\">Log Your Queries While Building a GraphQL Server</a>. It would be interesting to create an example that's <code>OpenTelemetry</code> compliant... perhaps that's one for another day (this articles getting a bit long üò©).</p>\n<h1 id=\"conclusion\" style=\"position:relative;\"><a href=\"#conclusion\" aria-label=\"conclusion permalink\" class=\"auto-link-header before\"><svg aria-hidden=\"true\" height=\"40\" width=\"40\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Conclusion</h1>\n<p>That's it folks! We've seen that the Hot Chocolate implementation nicely fulfils not just the 80% crud use case but can also deal with the other responsibilities we typically see with our REST services in the wild.</p>"}}},"related":{"edges":[{"node":{"title":"Adding environments to ASP.NET Core with React.js SPA","slug":"aspnet-core-react-spa-adding-environments","hero":{"file":{"url":"//images.ctfassets.net/wjg1udsw901v/1IeybLQIjDnbaXTl4sbqTn/294b0ef4ad9095ee3633f6c38a0e35aa/hero.png"},"title":".env + dotnet core"}}},{"node":{"title":".NET & GRPC What they forgot to tell you","slug":"dotnet-grpc-forgot-to-tell-you","hero":{"file":{"url":"//images.ctfassets.net/wjg1udsw901v/5m1MwxccFfmDxkLKcq3dBt/b54fc31b09d0a266a3d8cd5082839976/grpc-logojpg.jpg"},"title":"GRPC Logo"}}},{"node":{"title":"Creating my dream tech blog with GatsbyJS","slug":"gatsby-tech-blog-starter","hero":{"file":{"url":"//images.ctfassets.net/wjg1udsw901v/6hjsGXkoyitmyiEuBdeTP2/c77e74af9235ac775f18836e2de07cac/gatsby-logo.jpg"},"title":"Gatsby JS"}}}]}},"pageContext":{"slug":"aspnet-graphql-server-with-hot-chocolate","tags":["graphql","hotchocolate","graphql-voyager","asp.net","authentication","authorization","versioning","rest","chilli-cream","logging","open-telemetry","banana-cake-pop"]}}}