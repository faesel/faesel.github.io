{"componentChunkName":"component---src-templates-blog-js","path":"/blog/dotnet-grpc-forgot-to-tell-you","result":{"data":{"site":{"siteMetadata":{"siteUrl":"https://www.faesel.com"}},"contentfulBlog":{"title":".NET & GRPC What they forgot to tell you","slug":"dotnet-grpc-forgot-to-tell-you","tags":["grpc",".net","c#","asp.net","grpc-web","rest","nswag","proto-files","nuget","grpc-reflection","bloomrpc"],"hero":{"file":{"url":"//images.ctfassets.net/wjg1udsw901v/5m1MwxccFfmDxkLKcq3dBt/b54fc31b09d0a266a3d8cd5082839976/grpc-logojpg.jpg"},"title":"GRPC Logo"},"datePublished":"September 7th, 2020","iso8601DatePublished":"2020-09-07T23:00:00.000Z","bodym":{"childMarkdownRemark":{"excerpt":"As an engineer, I have always had a heavy reliance‚Ä¶","timeToRead":11,"html":"<p>As an engineer, I have always had a heavy reliance on REST'ful API's for passing information between applications. With the introduction of <a href=\"https://swagger.io/specification/\" target=\"_blank\" rel=\"nofollow\">open API specification</a> now in version 3.0.3, integration has never been easier. The push to break monoliths into microservices has further boosted its usage, however I always found one size never fits all.</p>\n<h2 id=\"where-rest-falls-down-\" style=\"position:relative;\"><a href=\"#where-rest-falls-down-\" aria-label=\"where rest falls down  permalink\" class=\"auto-link-header before\"><svg aria-hidden=\"true\" height=\"40\" width=\"40\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Where REST falls down üëé</h2>\n<p>RESTful services have many shortfalls built in, if you're in my boat and most of the time your creating services and working on client applications. Having to tailor a client library to call those services has always been a tiresome task. 3rd party tooling like <a href=\"https://github.com/RicoSuter/NSwag\" target=\"_blank\" rel=\"nofollow\">Nswag</a> made some attempt to fix this problem however I still find breaking changes between versions that make huge changesets across all your endpoints. If your working across multiple languages like C# and Javascript your work doubles up. </p>\n<p>There are also encumbrances experienced when mixing batch/bulk operations, overnight jobs with REST'ful APIs. Leading to complex solutions that auto scale or spread load over time. Having to go through each request-response cycle on bulk is just in-efficient.</p>\n<p>In most cases, responses are also in the form of JSON which is designed to cater for human readability at the expense of being inefficient. If you talking machine to machine readability is not a concern?  </p>\n<p>Lets also not mention those endless subjective PR threads trying to decide whats RESTful and whats not üòá.</p>\n<h2 id=\"can-grpc-fill-the-gaps-ü§∑‚ôÇÔ∏è\" style=\"position:relative;\"><a href=\"#can-grpc-fill-the-gaps-%F0%9F%A4%B7%E2%99%82%EF%B8%8F\" aria-label=\"can grpc fill the gaps ü§∑‚ôÇÔ∏è permalink\" class=\"auto-link-header before\"><svg aria-hidden=\"true\" height=\"40\" width=\"40\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Can GRPC fill the gaps ü§∑‚Äç‚ôÇÔ∏è</h2>\n<p>If you experienced the REST'ful pains above, GRPC's got your back. To get a quick demonstration of its capabilities, I recommend <a href=\"http://wildermuth.com/2020/07/09/gRPC-Talk-at-netPonto\" target=\"_blank\" rel=\"nofollow\">Shawn Wildermuth's gRPC Talk at netPonto User Group (2020)</a> he explains it in a easy to understand way.</p>\n<p><iframe width=\"100%\" height=\"315\" src=\"https://www.youtube-nocookie.com/embed/3wUtQb6C7to?rel=0\" frameBorder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowFullScreen></iframe></p>\n<p>To sum up its capabilities it has two key differences to REST (if your already familiar with this, skip to section <strong>Things to look into</strong>).</p>\n<h3 id=\"1-proto-files\" style=\"position:relative;\"><a href=\"#1-proto-files\" aria-label=\"1 proto files permalink\" class=\"auto-link-header before\"><svg aria-hidden=\"true\" height=\"40\" width=\"40\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Proto files</h3>\n<p>Proto files contain the definition of your API in a structured spec compliant way. The code below shows a simple <em>GreetingsService</em> with a basic request and response.</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">syntax = &quot;proto3&quot;;\n\noption csharp_namespace = &quot;HelloService&quot;;\n\nservice GreetingsService {\n    rpc GetHello (HelloRequest) returns (HelloResponse);\n}\n\nmessage HelloRequest {\n    int32 HelloCount = 1;\n}\n\nmessage HelloResponse {\n    string HelloDescription = 1;\n}</code>\n        </deckgo-highlight-code>\n      \n<p>Proto files can then be used to transpile code <a href=\"https://grpc.io/docs/languages/\" target=\"_blank\" rel=\"nofollow\">into many languages</a>. When transpiling we have the option to either create code for a <strong>server</strong> or <strong>client</strong>. Code generation creates a base class <strong>GreetingsServiceBase</strong> for us (it's generated in the bin folder on build time). Eventually, you end up with a service that looks like this:</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">using Grpc.Core;\nusing HelloServer;\nusing System.Threading.Tasks;\n\nnamespace TaxServer.Services\n{\n    public class HelloGrpcService : GreetingsService.GreetingsServiceBase\n    {\n        public override async Task&lt;HelloResponse&gt; GetHello(HelloRequest request, ServerCallContext context)\n        {\n            return new HelloResponse { HelloDescription = $&quot;{request.HelloCount} Hellos to you!&quot; };\n        }\n    }\n}</code>\n        </deckgo-highlight-code>\n      \n<p>The act of sharing and distributing proto files means that consuming clients can easily create their own client code and be completely agnostic of language.</p>\n<h3 id=\"2-defining-requestresponse-lifecycle\" style=\"position:relative;\"><a href=\"#2-defining-requestresponse-lifecycle\" aria-label=\"2 defining requestresponse lifecycle permalink\" class=\"auto-link-header before\"><svg aria-hidden=\"true\" height=\"40\" width=\"40\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Defining request/response lifecycle</h3>\n<p>GRPC allows you to change its request/response lifecycle, it has 4 options described below,</p>\n<ul>\n<li><strong>Unary RPC's</strong>: Unary RPCs where the client sends a single request to the server and gets a single response back.</li>\n<li><strong>Server Streaming RPC's</strong>: Server streaming RPCs where the client sends a request to the server and gets a stream to read a sequence of messages back.</li>\n<li><strong>Client Streaming RPC's</strong>: Client streaming RPCs where the client writes a sequence of messages and sends them to the server, again using a provided stream.</li>\n<li><strong>Bi-Directional Streaming RPC's</strong>: Bidirectional streaming RPCs where both sides send a sequence of messages using a read-write stream.</li>\n</ul>\n<p><a href=\"https://grpc.io/docs/what-is-grpc/core-concepts/\" target=\"_blank\" rel=\"nofollow\"><em>Taken from GRPC.io</em></a></p>\n<p>These additional modes are more suited for batch processing over your traditional request/response lifecycle.</p>\n<h2 id=\"things-to-look-into-\" style=\"position:relative;\"><a href=\"#things-to-look-into-\" aria-label=\"things to look into  permalink\" class=\"auto-link-header before\"><svg aria-hidden=\"true\" height=\"40\" width=\"40\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Things to look into ‚úÖ</h2>\n<p>So far so great, getting to this point is relatively easy and straightforward. Problem is all the tutorials seem to end at this point üòü. To have a live API several additional concerns need to be addressed. My list was as follows:</p>\n<ol>\n<li>Check how we can consume/distribute .proto files</li>\n<li>How to create a health checking probe for a GRPC service</li>\n<li>How to version endpoints</li>\n<li>Can a .NET Framework client app consume a .NET Core GRPC server?</li>\n<li>How to debug with tools, call an endpoint</li>\n<li>Authentication and authorization</li>\n<li>Can you call the service from a browser?</li>\n</ol>\n<h3 id=\"1-check-how-we-can-consumedistribute-proto-files\" style=\"position:relative;\"><a href=\"#1-check-how-we-can-consumedistribute-proto-files\" aria-label=\"1 check how we can consumedistribute proto files permalink\" class=\"auto-link-header before\"><svg aria-hidden=\"true\" height=\"40\" width=\"40\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Check how we can consume/distribute .proto files</h3>\n<p>There are two different approaches to achieve this, mainly dependent on whether your service is internal or external public facing.</p>\n<h4 id=\"option-1---with-nuget-packages\" style=\"position:relative;\"><a href=\"#option-1---with-nuget-packages\" aria-label=\"option 1   with nuget packages permalink\" class=\"auto-link-header before\"><svg aria-hidden=\"true\" height=\"40\" width=\"40\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Option 1 - With nuget packages</h4>\n<p>Option one is to distribute your proto files using Nuget packages. This solution is recommended in the situation where you are using GRPC for internal services. Your solution structure would look something like this:</p>\n<ul>\n<li>\n<p>HelloService.Protos</p>\n<ul>\n<li>Hello.protos</li>\n</ul>\n</li>\n<li>\n<p>HelloService.Server</p>\n<ul>\n<li>Server code ... </li>\n</ul>\n</li>\n</ul>\n<p>In this case we would use a Nuspec file to package the .protos and output it into the following structure in the client app. Considering you could be consuming more than one GRPC service it might make sense to create subfolders to know where the proto file comes from.</p>\n<ul>\n<li>HelloClient\n/Protos/<strong>service name goes gere</strong>/Hello.protos</li>\n</ul>\n<p>From here the client application can generate its client service code using the protofile. If you want to go one step further there is a dotnet command you can use to integrate the proto file into the <strong>.csproj</strong> file using a <a href=\"https://docs.microsoft.com/en-us/aspnet/core/grpc/dotnet-grpc?view=aspnetcore-3.1\" target=\"_blank\" rel=\"nofollow\">dotnet command</a> which can be triggered after the installation of the package.</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">dotnet grpc add-file Hello.proto</code>\n        </deckgo-highlight-code>\n      \n<h4 id=\"option-2---with-a-discovery-endpoint\" style=\"position:relative;\"><a href=\"#option-2---with-a-discovery-endpoint\" aria-label=\"option 2   with a discovery endpoint permalink\" class=\"auto-link-header before\"><svg aria-hidden=\"true\" height=\"40\" width=\"40\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Option 2 - With a discovery endpoint</h4>\n<p>This approach is recommended if your GRPC service is a service meant for external consumers. The idea behind this approach is to expose which services/endpoints are available. The method is dependent on the <a href=\"https://www.nuget.org/packages/Grpc.Reflection/\" target=\"_blank\" rel=\"nofollow\"><strong>Grpc.Reflection</strong></a> Nuget package.</p>\n<p>The general approach is outlined <a href=\"https://github.com/grpc/grpc/blob/master/doc/csharp/server_reflection.md\" target=\"_blank\" rel=\"nofollow\">here</a>. </p>\n<p>Once implemented it allows you to use an endpoint from the server code to generate your client code. Dotnet has a <a href=\"https://www.nuget.org/packages/dotnet-grpc-cli/\" target=\"_blank\" rel=\"nofollow\">GRPC CLI tool</a>, that can read from a server reflection endpoint and produce a proto file out of it. The command looks like this,</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">dotnet grpc-cli dump https://localhost:5001 Reflection.HelloService</code>\n        </deckgo-highlight-code>\n      \n<p>You can also write the proto file to disk using this command</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">dotnet grpc-cli dump http://localhost:10042 Reflection.HelloService -o ./prot</code>\n        </deckgo-highlight-code>\n      \n<h3 id=\"2-how-to-create-a-health-checking-probe-for-a-grpc-service\" style=\"position:relative;\"><a href=\"#2-how-to-create-a-health-checking-probe-for-a-grpc-service\" aria-label=\"2 how to create a health checking probe for a grpc service permalink\" class=\"auto-link-header before\"><svg aria-hidden=\"true\" height=\"40\" width=\"40\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. How to create a health checking probe for a GRPC service</h3>\n<p>Health checking probe endpoints are useful for monitoring uptime as well as managing containers when services are unresponsive. GRPC specification has a defined structure for creating your health checking endpoint called the <a href=\"https://github.com/grpc/grpc/blob/master/doc/health-checking.md\" target=\"_blank\" rel=\"nofollow\"><strong>GRPC Health Checking Protocol</strong></a>. </p>\n<p>However, since we are using asp.net core we can get away from this and rely on middleware to do this for us with little code.</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">public void ConfigureServices(IServiceCollection services)\n{\n  services.AddGrpc();\n  services.AddHealthChecks();\n  ...\n}\n\npublic void Configure(IApplicationBuilder app)\n{\n  app.UseEndpoints(endpoints =&gt;\n  {\n    endpoints.MapHealthChecks(&quot;/healthz&quot;);\n    ...\n  });\n}</code>\n        </deckgo-highlight-code>\n      \n<p>Now when running locally <strong><a href=\"https://localhost:5001/healthz\" target=\"_blank\" rel=\"nofollow\">https://localhost:5001/healthz</a></strong> we can get a 200 response. Here is what the output logs look like:</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">      Request starting HTTP/2 GET https://localhost:5001/healthz\ninfo: Microsoft.AspNetCore.Routing.EndpointMiddleware[0]\n      Executing endpoint &#39;Health checks&#39;\ninfo: Microsoft.AspNetCore.Routing.EndpointMiddleware[1]\n      Executed endpoint &#39;Health checks&#39;\ninfo: Microsoft.AspNetCore.Hosting.Diagnostics[2]\n      Request finished in 19.056ms 200 text/plain</code>\n        </deckgo-highlight-code>\n      \n<h3 id=\"3-how-to-version-endpoints\" style=\"position:relative;\"><a href=\"#3-how-to-version-endpoints\" aria-label=\"3 how to version endpoints permalink\" class=\"auto-link-header before\"><svg aria-hidden=\"true\" height=\"40\" width=\"40\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. How to version endpoints</h3>\n<p>The problem of versioning is easily solved using namespaces, it's just a case of incorporating your version number into the namespace like so,</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">option csharp_namespace = &quot;HelloService.v1&quot;;</code>\n        </deckgo-highlight-code>\n      \n<p>For each version, you would have different proto files and different service implementations. When inheriting from the base we can be specific on the version we need.</p>\n<p><strong>Server Code</strong></p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">public class HelloGrpcService : HelloService.v1.GreetingsService.GreetingsServiceBase\n{\n}</code>\n        </deckgo-highlight-code>\n      \n<p><strong>Client Code</strong></p>\n<p>The namespaces segregate the types so it just works out.</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">//Version 1\nusing var channel = GrpcChannel.ForAddress(&quot;https://localhost:5001&quot;);\nvar client = new HelloService.v1.GreetingsService.GreetingsServiceClient(channel);\nvar response = await client.GetHello(new HelloService.v1.HelloRequest() { \n      HelloCount = 1\n});\n\n//Version 2\nusing var channel2 = GrpcChannel.ForAddress(&quot;https://localhost:5001&quot;);\nvar client2 = new HelloService.v2.GreetingsService.GreetingsServiceClient(channel);\nvar response2 = await client2.GetHello(new HelloService.v2.HelloRequest() {\n      HelloCount = 2\n});</code>\n        </deckgo-highlight-code>\n      \n<h3 id=\"4-can-a-net-framework-client-app-consume-a-net-core-grpc-server\" style=\"position:relative;\"><a href=\"#4-can-a-net-framework-client-app-consume-a-net-core-grpc-server\" aria-label=\"4 can a net framework client app consume a net core grpc server permalink\" class=\"auto-link-header before\"><svg aria-hidden=\"true\" height=\"40\" width=\"40\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. Can a .NET Framework client app consume a .NET Core GRPC server?</h3>\n<p>Turns out it can yes, however ... as GRPC is built upon HTTP/2 which is not supported in .net framework, making secure connections to your API is not possible. The client code for .net framework is very similar, we just pass a <strong>ChannelCredentials.Insecure</strong> option in when building the client.</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">var channel = new Channel(&quot;127.0.0.1&quot;, 5000, ChannelCredentials.Insecure);\nvar client = new GreetingsService.GreetingsServiceClient(channel);</code>\n        </deckgo-highlight-code>\n      \n<h3 id=\"5-how-to-debug-with-tools-call-an-endpoint\" style=\"position:relative;\"><a href=\"#5-how-to-debug-with-tools-call-an-endpoint\" aria-label=\"5 how to debug with tools call an endpoint permalink\" class=\"auto-link-header before\"><svg aria-hidden=\"true\" height=\"40\" width=\"40\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. How to debug with tools, call an endpoint</h3>\n<p>If you're like me and you've come from a REST background your most likely used to polished tools like Postman or Insomnia to test out your endpoints. Sadly these tools don't support GRPC üò¢... yet anyway...</p>\n<p>The <a href=\"https://github.com/grpc-ecosystem/awesome-grpc#lang-cs\" target=\"_blank\" rel=\"nofollow\">GRPC Tooling Community</a> is still in its infancy. There are however some new players that are emerging that get the job done, most notably for me BloomRPC. </p>\n<p><img src=\"//images.ctfassets.net/wjg1udsw901v/6p6bGkCU7Tpa3tMwPsoRxO/adb23285ed92ea9c2c757ef62a4600a9/BloomRPC.png\" alt=\"BloomRPC\"></p>\n<p>After importing in your proto files you get a great swagger-esk UI that automatically build up your request body from your proto file.</p>\n<h3 id=\"6-authentication-and-authorization\" style=\"position:relative;\"><a href=\"#6-authentication-and-authorization\" aria-label=\"6 authentication and authorization permalink\" class=\"auto-link-header before\"><svg aria-hidden=\"true\" height=\"40\" width=\"40\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6. Authentication and authorization</h3>\n<p>Because we are working under the guise of asp.net core we can take advantage of its authentication middleware. The following authentication methods are supported.</p>\n<ul>\n<li>Azure Active Directory</li>\n<li>Client Certificate</li>\n<li>IdentityServer</li>\n<li>JWT Token</li>\n<li>OAuth 2.0</li>\n<li>OpenID Connect</li>\n<li>WS-Federation</li>\n</ul>\n<p>Below is a simple code example of authenticating a JWT token with an identity service. As you can see its no different from a REST service.</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">public void ConfigureServices(IServiceCollection services)\n{\n    var authority = &quot;https://myidentityserver.com&quot;;\n\n    services\n        .AddAuthentication(&quot;Bearer&quot;)\n        .AddJwtBearer(&quot;Bearer&quot;, options =&gt;\n        {\n            options.Authority = authority;\n            options.RequireHttpsMetadata = false;\n            options.TokenValidationParameters = new TokenValidationParameters\n            {\n                ValidateAudience = false,\n            };\n            options.ConfigurationManager = new ConfigurationManager&lt;OpenIdConnectConfiguration&gt;\n            (\n                metadataAddress: authority + &quot;/.well-known/openid-configuration&quot;,\n                configRetriever: new OpenIdConnectConfigurationRetriever(),\n                docRetriever: new HttpDocumentRetriever { RequireHttps = false }\n            );\n            options.Events = new JwtBearerEvents\n            {\n                OnTokenValidated = context =&gt;\n                {\n                    var ci = (ClaimsIdentity)context.Principal.Identity;\n                    var authHeader = context.Request.Headers[&quot;Authorization&quot;];\n                    var token = authHeader.FirstOrDefault()?.Substring(7);\n                    if (token != null)\n                    {\n                        ci.AddClaim(new Claim(&quot;token&quot;, token));\n                    }\n\n                    return Task.CompletedTask;\n                }\n            };\n        });\n\n    services.AddAuthorization();\n    ...\n}\n\npublic void Configure(IApplicationBuilder app)\n{\n    app.UseAuthentication();\n    app.UseAuthorization();\n    ...\n}</code>\n        </deckgo-highlight-code>\n      \n<p>Below is output from an authenticated request:</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">      Request starting HTTP/2 POST https://localhost:5001/HelloGrpcService.GreetingsService/GetHello application/grpc\ninfo: Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerHandler[2]\n      Successfully validated the token.\ninfo: Microsoft.AspNetCore.Authorization.DefaultAuthorizationService[1]\n      Authorization was successful.\ninfo: Microsoft.AspNetCore.Routing.EndpointMiddleware[0]\n      Executing endpoint &#39;gRPC - /HelloGrpcService.GreetingsService/GetHello&#39;\nRequest parameter 1\nRequest came from test-client-id\ninfo: Microsoft.AspNetCore.Routing.EndpointMiddleware[1]\n      Executed endpoint &#39;gRPC - /HelloGrpcService.GreetingsService/GetHello&#39;\ninfo: Microsoft.AspNetCore.Hosting.Diagnostics[2]\n      Request finished in 5865.2411ms 200 application/grpc</code>\n        </deckgo-highlight-code>\n      \n<h3 id=\"7-can-you-call-the-service-from-a-browser\" style=\"position:relative;\"><a href=\"#7-can-you-call-the-service-from-a-browser\" aria-label=\"7 can you call the service from a browser permalink\" class=\"auto-link-header before\"><svg aria-hidden=\"true\" height=\"40\" width=\"40\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>7. Can you call the service from a browser?</h3>\n<p>Currently, as it stands the answer is no, browsers don't offer fine-grained control over API requests to support GRPC. However, there is some light at the end of the tunnel.</p>\n<p>Back in 2016 Google started working on a specification for \"GRPC for the browser\". You can read more about it <a href=\"https://grpc.io/blog/state-of-grpc-web/\" target=\"_blank\" rel=\"nofollow\">here</a> but in essence,</p>\n<blockquote>\n<p>The basic idea is to have the browser send normal HTTP requests (with Fetch or XHR) and have a small proxy in front of the gRPC server to translate the requests and responses to something the browser can use - grpc.io</p>\n</blockquote>\n<p>In the C# world, Microsoft has an implementation of this specification in their docs, <a href=\"https://docs.microsoft.com/en-gb/aspnet/core/grpc/browser?view=aspnetcore-3.1\" target=\"_blank\" rel=\"nofollow\">Use gRPC in browser apps</a>.</p>\n<p>There are some disclaimers to this, as gRPC supports streaming and bidirectional requests this addition is only recommended for unary requests. Due to this limiting factor helpers are present to turn it on and off for services when setting up GRPC services in the startup,</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">endpoints.MapGrpcService&lt;HelloGrpcService&gt;().EnableGrpcWeb().RequireCors(&quot;AllowAll&quot;);</code>\n        </deckgo-highlight-code>\n      \n<p>What I find particularly interesting is that the problem grpc-web solves is similar to the problems we have with .net framework (https/2 is not supported). Could this perhaps be an answer to getting secure requests working? ... sadly not yet! at the moment its not possible as grpc-web was was built on .net standard 2.1 so .net framework is not supported. Perhaps there might be movement on this in time to come.</p>\n<h2 id=\"things-i-missed-out\" style=\"position:relative;\"><a href=\"#things-i-missed-out\" aria-label=\"things i missed out permalink\" class=\"auto-link-header before\"><svg aria-hidden=\"true\" height=\"40\" width=\"40\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Things I missed out</h2>\n<ol>\n<li>Integration Testing, im a big fan of using in memory testing with Test Server it would be interesting to see if this works with a GRPC service.</li>\n</ol>\n<h2 id=\"useful-links\" style=\"position:relative;\"><a href=\"#useful-links\" aria-label=\"useful links permalink\" class=\"auto-link-header before\"><svg aria-hidden=\"true\" height=\"40\" width=\"40\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Useful Links</h2>\n<ol>\n<li><a href=\"https://github.com/grpc/grpc/tree/master/src/csharp\" target=\"_blank\" rel=\"nofollow\">C# Examples</a></li>\n<li><a href=\"https://github.com/grpc/grpc-dotnet/tree/master/examples\" target=\"_blank\" rel=\"nofollow\">More c# examples</a></li>\n</ol>"}}},"related":{"edges":[{"node":{"title":"How to Deconstruct objects in C# like we do in Javascript","slug":"deconstruct-objects-in-csharp-like-in-javascript","hero":{"file":{"url":"//images.ctfassets.net/wjg1udsw901v/4l5ONHEazPnD41lO0henyW/d4cbb6edf21c40cdb3e340faf620a270/deconstruction.jpg"},"title":"Deconstruct"}}},{"node":{"title":"ASP.NET GraphQL server with Hot Chocolate","slug":"aspnet-graphql-server-with-hot-chocolate","hero":{"file":{"url":"//images.ctfassets.net/wjg1udsw901v/74JrRnpexhOnSAsBwNOPV7/635bc389cea0de36f3158df45483ae85/graphql.jpg"},"title":"GraphQL With Hot Chocolate"}}},{"node":{"title":"Adding environments to ASP.NET Core with React.js SPA","slug":"aspnet-core-react-spa-adding-environments","hero":{"file":{"url":"//images.ctfassets.net/wjg1udsw901v/1IeybLQIjDnbaXTl4sbqTn/294b0ef4ad9095ee3633f6c38a0e35aa/hero.png"},"title":".env + dotnet core"}}}]}},"pageContext":{"slug":"dotnet-grpc-forgot-to-tell-you","tags":["grpc",".net","c#","asp.net","grpc-web","rest","nswag","proto-files","nuget","grpc-reflection","bloomrpc"]}}}