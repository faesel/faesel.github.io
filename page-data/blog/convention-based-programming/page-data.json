{"componentChunkName":"component---src-templates-blog-js","path":"/blog/convention-based-programming","result":{"data":{"site":{"siteMetadata":{"siteUrl":"https://www.faesel.com"}},"contentfulBlog":{"title":"Fix poor project structure with Convention Based Programming","slug":"convention-based-programming","tags":["convention","unit-test","project-structure"],"hero":{"file":{"url":"//images.ctfassets.net/wjg1udsw901v/27s4Gn7WXRTKhSaaWBU2RN/c057b731733a4d8943365bdeaeb71147/alain-pham-P_qvsF7Yodw-unsplash.jpg"},"title":"Contention Based Programming"},"datePublished":"August 19th, 2017","iso8601DatePublished":"2017-08-19T23:00:00.000Z","bodym":{"childMarkdownRemark":{"excerpt":"Having looked at a number of projects in my…","timeToRead":5,"html":"<p>Having looked at a number of projects in my lifetime, I always come across classes named something like \"CustomerService\" with similar variations (usually in the same project calling each other) ranging from \"CustomerProvider / Helper /Manager / Store / etc...\".</p>\n<blockquote>\n<p>There are two hard things in computer science: cache invalidation, naming things, and off-by-one errors - PhilKarlton</p>\n</blockquote>\n<p>As a new developer working on a project it becomes really hard to figure out what the structure is, and in the case of adding code what to name classes. Naming and structure always seem to be a developers achilles heel(almost akin to superman and kryptonite).</p>\n<p>So, I wanted to come up with a solution to the problem, something more structured that helps facilitate better naming and structuring and the way I decided to do this is through dependency injection. </p>\n<p>By now we are all familiar with Inversion of control, and comfortable using it to decouple dependencies within our applications. Most of us have dabbled with the usual suspects CastleWindsor, AutoFaq, Ninject to name a few. </p>\n<p>One thing people don’t realise is we can also utilise these frameworks to enforce good structure as well as unit test the structure itself to ensure new developers don’t stray from the named path. For the examples below I'm going to use Castle Windsor.</p>\n<h1>Step 1 – Define the structure and start naming the onion layers</h1>\n<p>The codebases of yester-year were usually architected using a n-tier structure typically following the pattern: </p>\n<p>Presentation Layer (Controller) > Business Layer (Service) > Data Layer (Repository)</p>\n<p>As time progressed new patterns emerged the structure became more complex however we still try to adopt some form of onion layering within the application. Whether it’s one onion or many within a single solution we should always strive to define what the layers are in the application.</p>\n<p>So, to start we should define:</p>\n<ol>\n<li>What the onion layer is named (forming groups of similar classes).</li>\n<li>What the responsibility of each layer is.</li>\n</ol>\n<h1>Step 2 – Create your conventions</h1>\n<p>Now that we have some understanding of the layers, we can start defining them in code. I use an empty interface to do this. Note Castle distinguishes these layers as 'Conventions'.</p>\n\n        <deckgo-highlight-code language=\"csharp\"  terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">/// A class that contains business logic, it also does not directly access any data source.\npublic interface IService\n{\n}</code>\n        </deckgo-highlight-code>\n      \n<p>Note the interface has no bearing on logic, and does not alter how the app behaves. It’s simply used as a marker to distinguish the layers of the application. A small description is also provided to define what the responsibility of the layer is. These conventions are also a way to document the structure of the application.</p>\n<h1>Step 3 – Install all dependency’s using the convention.</h1>\n<p>Now that we have a convention we can blanket install all classes subscribing to that convention, if your using castle Windsor there is a slight difference in how this is done depending on whether you apply the convention directly on the class itself or if you apply it to another interface.</p>\n<p><strong>Applying it to an interface</strong></p>\n\n        <deckgo-highlight-code language=\"csharp\"  terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">/// A class that contains business logic, it also does not directly access any data source.\npublic interface IService\n{\n}\n\n/// Blanket install all IServies\ncontainer.Register(Classes.FromAssembly(Assembly.Load(&quot;Assembly name goes here&quot;))\n    .BasedOn(IService)\n    .WithService.AllInterfaces()\n    .LifestyleSingleton());\n\n/// Example usage\npublic interface ICustomerService : IService\npublic class CustomerService : ICustomerService</code>\n        </deckgo-highlight-code>\n      \n<p><strong>Applying it to a class</strong></p>\n<p>When applying it to class the installation has a slight difference.</p>\n\n        <deckgo-highlight-code language=\"csharp\"  terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">/// A class that contains a business rule, it validates whether the rule has been met\npublic interface IRule\n{\n string ApplyRule();\n}\n\ncontainer.Register(Classes.FromAssembly(Assembly.Load(&quot;Assembly name goes here&quot;))\n .BasedOn(IRule)\n .WithService.Base()\n .LifestyleSingleton());\n\npublic class CustomerRule : IRule</code>\n        </deckgo-highlight-code>\n      \n<p>When creating a new class that fits within a pre-defined convention installation becomes a walk in the park, just apply the convention interface and you’re done.</p>\n<h1>Step 4 – Unit testing structure</h1>\n<p>Now that we have our convention setup and we are installing all classes with that convention we can apply a unit tests that will check against the structure. We are testing on two things here:</p>\n<ol>\n<li>Only Services should have a‘Service’ Suffix</li>\n<li>Only Services should exist in a ‘Service’ namespace</li>\n</ol>\n\n        <deckgo-highlight-code language=\"csharp\"  terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">[TestFixture]\npublic class TestSolutionConventionTests\n{\n    [SetUp]\n    public void Setup()\n    {\n        // Register all dependencys in the project using castle\n        RegisterDependencies(); \n    }\n\n    [Test]\n    public void OnlyServices_HaveServiceSuffix()\n    {\n        // Get access to IWindsorContainer\n        var container = DependencyResolver.Container; \n        // Get all classes in the application where the name ends with Service (using reflection).\n        var allServices = GetPublicClassesFromApplicationAssembly(c =&gt; c.Name.EndsWith(&quot;Service&quot;), &quot;Assembly name where service exists goes here&quot;);\n        // Get all services installed within castles container that use the interface IService\n        var registeredServices = GetImplementationTypesFor(typeof(IService), container);\n\n        // Assert the names all match and are equal\n        allServices.ToList().Should().Equal(registeredManagers, (ac, rc) =&gt; ac.Name == rc.Name);\n    }\n\n    [Test]\n    public void OnlyServices_LiveInServicesNamespace()\n    {\n        var container = DependencyResolver.Container; \n        // Get all classes in the application where the namespace contains Service\n        var allServices = GetPublicClassesFromApplicationAssembly(c =&gt; c.Namespace.Contains(&quot;Service&quot;), &quot;Assembly name where service exists goes here&quot;);\n        var registeredServices = GetImplementationTypesFor(typeof(IService), container);\n\n        allServices.ToList().Should().Equal(registeredManager, (ac, rc) =&gt; ac.Name == rc.Name);\n    }\n\n    private Type[] GetPublicClassesFromApplicationAssembly(Predicate where, string assemblyName)\n    {\n        return Assembly.Load(assemblyName).GetExportedTypes()\n            .Where(t =&gt; t.IsClass)\n            .Where(t =&gt; t.IsAbstract == false)\n            .Where(where.Invoke)\n            .OrderBy(t =&gt; t.Name)\n            .ToArray();\n    }\n\n    private Type[] GetImplementationTypesFor(Type type, IWindsorContainer container)\n    {\n        return container.Kernel.GetAssignableHandlers(type)\n            .Select(h =&gt; h.ComponentModel.Implementation)\n            .OrderBy(t =&gt; t.Name)\n            .ToArray();\n    }\n}</code>\n        </deckgo-highlight-code>\n      \n<p>Picture below describes what these unit tests protect against:</p>\n<p><img src=\"//images.ctfassets.net/wjg1udsw901v/5DsNc00VzOuEgttxz02Wh0/a5d882981f31c1fad410cea2e30af5dd/conventionexample.jpg\" alt=\"Convention Based Programming - Unit tests\"></p>\n<h1>Step 5 – Introducing new conventions</h1>\n<p>As your solution evolves you’re going to come across certain scenarios where the responsibilities of a class don’t fit into the conventions defined (as we have a list of conventions with descriptions it’s easy to distinguish if a new convention is needed). These scenarios will mainly occur at the beginning phase of a new application (as its rapidly evolving) and as conventions get defined you will find that having to define a new one will become an increasingly rare activity.</p>\n<p>This process should mitigate the scenario of having a customer/service/manager/provider…</p>\n<h1>Step 6 – Sharing conventions across projects unified code base</h1>\n<p>Once we’ve established some conventions for a project we can easily extract these out into a separate project and package it as a NuGet package. This allows us to apply the conventions to other solutions giving us a unified structure that looks the same from one solution to another.</p>\n<p>New developers will surely appreciate this, and as a co-worker sitting next to them the wtf count will be below uncomfortable thresholds!</p>"}}}},"pageContext":{"slug":"convention-based-programming"}}}