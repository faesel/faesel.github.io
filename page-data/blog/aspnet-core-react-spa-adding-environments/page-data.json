{"componentChunkName":"component---src-templates-blog-js","path":"/blog/aspnet-core-react-spa-adding-environments","result":{"data":{"site":{"siteMetadata":{"siteUrl":"https://www.faesel.com"}},"contentfulBlog":{"title":"Adding environments to ASP.NET Core with React.js SPA","slug":"aspnet-core-react-spa-adding-environments","tags":["react","spa","asp.net","dotnet core","environments","env-cmd","shx","template","msbuild",".env"],"hero":{"file":{"url":"//images.ctfassets.net/wjg1udsw901v/1IeybLQIjDnbaXTl4sbqTn/294b0ef4ad9095ee3633f6c38a0e35aa/hero.png"},"title":".env + dotnet core"},"datePublished":"January 19th, 2021","iso8601DatePublished":"2021-01-19T00:00:00.000Z","bodym":{"childMarkdownRemark":{"excerpt":"Recently I started working on a project that was‚Ä¶","timeToRead":10,"html":"<p>Recently I started working on a project that was created from the <strong>ASP.NET SPA template for react</strong>. It's one of the templates you get by default with dotnet and can be created by running <code>dotnet new react</code>.</p>\n<p>The template creates a dotnet webapp which is designed to be an API backend and links it with a react project to power the UI. When running the project from dotnet, static files are built from the react project and served up.</p>\n<p>In terms of running the application with different environments, the dotnet perspective is fairly straight forward as we can simply use the environment variable <code>ASPNETCORE_ENVIRONMENT</code>. But the question is how do we pass this variable to the SPA so that we can shift between different environments?</p>\n<p>Having trawled the internet I didn't see any examples, so I decided to create my own!</p>\n<h1 id=\"understanding-the-aspnet-spa-template-\" style=\"position:relative;\"><a href=\"#understanding-the-aspnet-spa-template-\" aria-label=\"understanding the aspnet spa template  permalink\" class=\"auto-link-header before\"><svg aria-hidden=\"true\" height=\"40\" width=\"40\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Understanding the ASP.NET spa template üîç</h1>\n<p>Let's begin by creating a boilerplate solution with <code>dotnet new react</code>. Once the solution is created we end up with a backend API with a <code>WeatherForecastController</code>, and a front end app located in the <code>ClientApp</code> folder.</p>\n<p><img src=\"//images.ctfassets.net/wjg1udsw901v/65iH6wUZxUc6JSNON5gWTK/a704de8ffa2dd0d4a33eef19ebf92390/folder-structure.png\" alt=\"Dotnet SPA Folder Structure\"></p>\n<p>Since this is an integrated spa, from the root of the project we are able to <code>dotnet run</code> and spin up not only the dotnet project but also the react spa.</p>\n<h2 id=\"client-app\" style=\"position:relative;\"><a href=\"#client-app\" aria-label=\"client app permalink\" class=\"auto-link-header before\"><svg aria-hidden=\"true\" height=\"40\" width=\"40\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Client App</h2>\n<p>The client app itself is in a completely segregated app, there's nothing special added here to make it all connect up. All your standard commands to <code>npm install/build</code> are all available to you. In fact, the template has been build based on the implementation of <code>create-react-app</code>.</p>\n<p>You can also start up the project from here with <code>npm run start</code> command which will spin up a development server <strong>independent of your backend code</strong>. The execution and configuration is handled for us using <code>react-scripts</code> which was designed to help set up react projects without stress, featuring things like hot module reloading, deployment builds etc ... all standard-issue so far. So you get these npm scripts setup for you,</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">  &quot;scripts&quot;: {\n    &quot;start&quot;: &quot;rimraf ./build &amp;&amp; react-scripts start&quot;,\n    &quot;build&quot;: &quot;react-scripts build&quot;,\n    &quot;test&quot;: &quot;cross-env CI=true react-scripts test --env=jsdom&quot;,\n    &quot;eject&quot;: &quot;react-scripts eject&quot;,\n    &quot;lint&quot;: &quot;eslint ./src/&quot;\n  },</code>\n        </deckgo-highlight-code>\n      \n<h2 id=\"startup-class\" style=\"position:relative;\"><a href=\"#startup-class\" aria-label=\"startup class permalink\" class=\"auto-link-header before\"><svg aria-hidden=\"true\" height=\"40\" width=\"40\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Startup Class</h2>\n<p>The glue that connects the backend to the frontend can be found in the <code>Startup.cs</code> class. Working from top down the first code block of interest is within the <em>ConfigureServices</em> function,</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">services.AddSpaStaticFiles(configuration =&gt;\n{\n  configuration.RootPath = &quot;ClientApp/build&quot;;\n});</code>\n        </deckgo-highlight-code>\n      \n<p>This block essentially tells your dotnet app where to find the static resources (production builds) of your spa within its bin folder. So running the command <code>dotnet publish --configuration Release</code> creates a <strong>ClientApp/Build</strong> folder with a production optimised (ie npm run build) version of our SPA, the root path simply points to this.</p>\n<p><img src=\"//images.ctfassets.net/wjg1udsw901v/4tIwYVA6pYWrGctHAzMXHT/d0836b601480a1962a7693bf4cd8b653/spa-build-folder.png\" alt=\"clientapp-build-folder\"></p>\n<p>The next block to notice is in the <em>Configure</em> function,</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">app.UseEndpoints(endpoints =&gt;\n{\n    endpoints.MapControllerRoute(\n        name: &quot;default&quot;,\n        pattern: &quot;{controller}/{action=Index}/{id?}&quot;);\n});\n\napp.UseSpa(spa =&gt;\n{\n    spa.Options.SourcePath = &quot;ClientApp&quot;;\n\n    if (env.IsDevelopment())\n    {\n        spa.UseReactDevelopmentServer(npmScript: &quot;start&quot;);\n    }\n});</code>\n        </deckgo-highlight-code>\n      \n<p>There are two things that are happening here, the first is that we have dotnet server side routing connected up (with app.UseEndpoints() middleware), this means that upon receiving a HTTP request server-side routing will always take priority over client-side routing. If server-side routes fall through without matching an endpoint, we use the app.UseSpa() middleware to redirect all requests to the default page (which is your index.html file triggering the spa to load).</p>\n<p>The next point is that from here we can also configure the location of our client-side source code, and the command we need to use to run our react spa as a development server when debugging.</p>\n<h2 id=\"msbuild--running-npm-commands\" style=\"position:relative;\"><a href=\"#msbuild--running-npm-commands\" aria-label=\"msbuild  running npm commands permalink\" class=\"auto-link-header before\"><svg aria-hidden=\"true\" height=\"40\" width=\"40\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MSBuild &#x26; Running NPM Commands</h2>\n<p>The remaining magic is all located in the .csproj file we got 2 core components here the first is the Debug target,</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">&lt;Target Name=&quot;DebugEnsureNodeEnv&quot; BeforeTargets=&quot;Build&quot; Condition=&quot; &#39;$(Configuration)&#39; == &#39;Debug&#39; And !Exists(&#39;$(SpaRoot)node_modules&#39;) &quot;&gt;\n  &lt;!-- Ensure Node.js is installed --&gt;\n  &lt;Exec Command=&quot;node --version&quot; ContinueOnError=&quot;true&quot;&gt;\n    &lt;Output TaskParameter=&quot;ExitCode&quot; PropertyName=&quot;ErrorCode&quot; /&gt;\n  &lt;/Exec&gt;\n  &lt;Error Condition=&quot;&#39;$(ErrorCode)&#39; != &#39;0&#39;&quot; Text=&quot;Node.js is required to build and run this project. To continue, please install Node.js from https://nodejs.org/, and then restart your command prompt or IDE.&quot; /&gt;\n  &lt;Message Importance=&quot;high&quot; Text=&quot;Restoring dependencies using &#39;npm&#39;. This may take several minutes...&quot; /&gt;\n  &lt;Exec WorkingDirectory=&quot;$(SpaRoot)&quot; Command=&quot;npm install&quot; /&gt;\n&lt;/Target&gt;</code>\n        </deckgo-highlight-code>\n      \n<p>This chunky block of code runs an <code>npm install</code> command before building your dotnet application. It also features a nice check to ensure you got Node.js installed (I guess for the backend people üòÅ). It does this with the <code>&#x3C;Exec WorkingDirectory=\"$(SpaRoot)\" Command=\"npm install\" /></code> command runner (note SpaRoot is defined a the top as a static property pointing to <strong>ClientApp\\</strong>).</p>\n<p>The second part is the publish target,</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">&lt;Target Name=&quot;PublishRunWebpack&quot; AfterTargets=&quot;ComputeFilesToPublish&quot;&gt;\n  &lt;!-- As part of publishing, ensure the JS resources are freshly built in production mode --&gt;\n  &lt;Exec WorkingDirectory=&quot;$(SpaRoot)&quot; Command=&quot;npm install&quot; /&gt;\n  &lt;Exec WorkingDirectory=&quot;$(SpaRoot)&quot; Command=&quot;npm run build&quot; /&gt;\n\n  &lt;!-- Include the newly-built files in the publish output --&gt;\n  &lt;ItemGroup&gt;\n    &lt;DistFiles Include=&quot;$(SpaRoot)build\\**&quot; /&gt;\n    &lt;ResolvedFileToPublish Include=&quot;@(DistFiles-&gt;&#39;%(FullPath)&#39;)&quot; Exclude=&quot;@(ResolvedFileToPublish)&quot;&gt;\n      &lt;RelativePath&gt;%(DistFiles.Identity)&lt;/RelativePath&gt;\n      &lt;CopyToPublishDirectory&gt;PreserveNewest&lt;/CopyToPublishDirectory&gt;\n      &lt;ExcludeFromSingleFile&gt;true&lt;/ExcludeFromSingleFile&gt;\n    &lt;/ResolvedFileToPublish&gt;\n  &lt;/ItemGroup&gt;\n&lt;/Target&gt;</code>\n        </deckgo-highlight-code>\n      \n<p>Again fairly similar concept running a publish first installs dependencies then builds the project. The build artefacts get created in the <strong>ClientApp\\build</strong> folder. The item group block then ensures the build assets are included in your <strong>bin\\ClientApp\\build</strong> folder.</p>\n<h2 id=\"summary\" style=\"position:relative;\"><a href=\"#summary\" aria-label=\"summary permalink\" class=\"auto-link-header before\"><svg aria-hidden=\"true\" height=\"40\" width=\"40\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Summary</h2>\n<p>So to summarise, when running in debug mode</p>\n<ol>\n<li>We npm install dependencies</li>\n<li>Build and run the dotnet app</li>\n<li>Run an npm development server</li>\n<li>Begin routing all calls to the backend, and where it fails to the default client page.</li>\n</ol>\n<p>In the case of a published application</p>\n<ol>\n<li>We create a published version of the dotnet application</li>\n<li>We npm install dependencies</li>\n<li>We create a production build of the spa in the folder <strong>ClientApp\\build</strong></li>\n<li>Static files from the spa are included in the output</li>\n<li>Running the application now has a packaged version of the spa its static files are served up upon running the backend. </li>\n</ol>\n<p>This is all well and great so far... but the react app gets pre built.. what if we need to run it as part of a different environment? Currently, it's all running off a single <code>.env</code> file!</p>\n<h1 id=\"adding-environments-\" style=\"position:relative;\"><a href=\"#adding-environments-\" aria-label=\"adding environments  permalink\" class=\"auto-link-header before\"><svg aria-hidden=\"true\" height=\"40\" width=\"40\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Adding environments üÜï</h1>\n<p>Below is my solution for getting environments running across the stack, it also conforms to the dev-ops ethos of,</p>\n<blockquote>\n<p>Build once and deploy many times.</p>\n</blockquote>\n<h2 id=\"install-the-dependencies\" style=\"position:relative;\"><a href=\"#install-the-dependencies\" aria-label=\"install the dependencies permalink\" class=\"auto-link-header before\"><svg aria-hidden=\"true\" height=\"40\" width=\"40\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Install the dependencies</h2>\n<p>To being adding environments we first need to ensure our npm app can support it. For this, we will use the well know <a href=\"https://www.npmjs.com/package/env-cmd\" target=\"_blank\" rel=\"nofollow\">env-cmd</a>. </p>\n<p>We will also be needing something to manipulate the build folders generated by react-scripts. Since all operating systems are equipped with CLI commands to rename/remove files we don't need anything special to do this. However, because these commands differ from one operating system to the next, it's always a good practice to use something like <a href=\"https://www.npmjs.com/package/shx\" target=\"_blank\" rel=\"nofollow\">shx</a> to ensure it works cross-platform.</p>\n<p>So let's start with running the install command in the ClientApp folder,</p>\n<p><code>npm install env-cmd shx --save-dev</code></p>\n<h2 id=\"add-your-environment-files\" style=\"position:relative;\"><a href=\"#add-your-environment-files\" aria-label=\"add your environment files permalink\" class=\"auto-link-header before\"><svg aria-hidden=\"true\" height=\"40\" width=\"40\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Add your environment files</h2>\n<p>Next let's start creating some environment files, the file structure should look something like this, with the .env file containing settings shared across all the environments:</p>\n<ul>\n<li>.env</li>\n<li>.env.staging</li>\n<li>.env.production</li>\n</ul>\n<p>Any key on these files need to be prefixed with <code>REACT_APP_</code> this is a safety feature build in,</p>\n<blockquote>\n<p>You must create custom environment variables beginning with REACT<em>APP</em>. Any other variables except NODE_ENV will be ignored to avoid accidentally exposing a private key on the machine that could have the same name.</p>\n</blockquote>\n<p>For now, let's add just add an environment variable that tells us which environment we are in. Do this for both production and staging .env files.</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">REACT_APP_ENV=&#39;production&#39;</code>\n        </deckgo-highlight-code>\n      \n<p>To show our environment on the page lets also create a <em>config.js</em> file, that accesses the environment variable.</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">export const config = {\n    ENVIRONMENT: process.env.REACT_APP_ENV \n};</code>\n        </deckgo-highlight-code>\n      \n<p>And finally output it to the page,</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">import React, { Component } from &#39;react&#39;;\nimport { Container } from &#39;reactstrap&#39;;\nimport { NavMenu } from &#39;./NavMenu&#39;;\nimport { config } from &#39;../config&#39;;\n\nexport class Layout extends Component {\n  static displayName = Layout.name;\n\n  render () {\n    return (\n      &lt;div&gt;\n        {config.ENVIRONMENT}\n        &lt;NavMenu /&gt;\n        &lt;Container&gt;\n          {this.props.children}\n        &lt;/Container&gt;\n      &lt;/div&gt;\n    );\n  }\n}</code>\n        </deckgo-highlight-code>\n      \n<h2 id=\"add-your-build-scripts\" style=\"position:relative;\"><a href=\"#add-your-build-scripts\" aria-label=\"add your build scripts permalink\" class=\"auto-link-header before\"><svg aria-hidden=\"true\" height=\"40\" width=\"40\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Add your build scripts</h2>\n<p>Build scripts are now needed to trigger the environments, we need to make the following amends to the npm scripts section,</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">  &quot;scripts&quot;: {\n    &quot;build:staging&quot;: &quot;env-cmd -f .env.staging react-scripts build &amp;&amp; shx rm -rf staging &amp;&amp; shx cp -r build staging&quot;,\n    &quot;build:production&quot;: &quot;env-cmd -f .env.production react-scripts build &amp;&amp; shx rm -rf production &amp;&amp; shx cp -r build production&quot;,\n    &quot;start:staging&quot;: &quot;rimraf ./build &amp;&amp; env-cmd -f .env.staging react-scripts start&quot;,\n    &quot;start:production&quot;: &quot;rimraf ./build &amp;&amp; env-cmd -f .env.production react-scripts start&quot;,\n  }</code>\n        </deckgo-highlight-code>\n      \n<p>The scripts prefixed with <em>build</em> are using env-cmd with its respective environment file to create a production build of the app. The shx part is then firstly removing the folder staging/production then copying the <em>build</em> files react-script creates into an environment specific folder.</p>\n<p>Similarly the scripts prefixed with <em>start</em> run the app using a certain environment. Note if your trying to run this from the dotnet app, you will need to change the Startup.cs > UseReactDevelopmentServer function to,</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">spa.UseReactDevelopmentServer(npmScript: &quot;start:production&quot;);</code>\n        </deckgo-highlight-code>\n      \n<p>Now that this is set up, running the app should show the environment variables.</p>\n<h2 id=\"modifying-your-csproj\" style=\"position:relative;\"><a href=\"#modifying-your-csproj\" aria-label=\"modifying your csproj permalink\" class=\"auto-link-header before\"><svg aria-hidden=\"true\" height=\"40\" width=\"40\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Modifying your .csproj</h2>\n<p>The next step is to get this working with <code>dotnet publish</code>! To do this we need to modify the <strong>PublishRunWebpack</strong> target in the .csproj file to,</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">&lt;Target Name=&quot;PublishRunWebpack&quot; AfterTargets=&quot;ComputeFilesToPublish&quot;&gt;\n  &lt;Exec WorkingDirectory=&quot;$(SpaRoot)&quot; Command=&quot;npm install&quot;/&gt;\n\n  &lt;Message Importance=&quot;high&quot; Text=&quot;Started building staging version of the spa ...&quot; Condition=&quot; &#39;$(Configuration)&#39; == &#39;Release&#39; &quot;/&gt;\n  &lt;Exec WorkingDirectory=&quot;$(SpaRoot)&quot; Command=&quot;npm run build:staging&quot; Condition=&quot; &#39;$(Configuration)&#39; == &#39;Release&#39; &quot;/&gt;\n  &lt;Message Importance=&quot;high&quot; Text=&quot;Started building production version of the spa ...&quot; Condition=&quot; &#39;$(Configuration)&#39; == &#39;Release&#39; &quot;/&gt;\n  &lt;Exec WorkingDirectory=&quot;$(SpaRoot)&quot; Command=&quot;npm run build:production&quot; Condition=&quot; &#39;$(Configuration)&#39; == &#39;Release&#39; &quot;/&gt;\n\n  &lt;Exec WorkingDirectory=&quot;$(SpaRoot)&quot; Command=&quot;npm run build&quot; Condition=&quot; &#39;$(Configuration)&#39; == &#39;Debug&#39; &quot; /&gt;\n  &lt;ItemGroup&gt;\n    &lt;DistFiles Include=&quot;$(SpaRoot)build\\**&quot; Condition=&quot; &#39;$(Configuration)&#39; == &#39;Debug&#39; &quot; /&gt;\n    &lt;DistFiles Include=&quot;$(SpaRoot)staging\\**&quot; Condition=&quot; &#39;$(Configuration)&#39; == &#39;Release&#39; &quot; /&gt;\n    &lt;DistFiles Include=&quot;$(SpaRoot)production\\**&quot; Condition=&quot; &#39;$(Configuration)&#39; == &#39;Release&#39; &quot; /&gt;\n    &lt;ResolvedFileToPublish Include=&quot;@(DistFiles-&gt;&#39;%(FullPath)&#39;)&quot; Exclude=&quot;@(ResolvedFileToPublish)&quot;&gt;\n      &lt;RelativePath&gt;%(DistFiles.Identity)&lt;/RelativePath&gt;\n      &lt;CopyToPublishDirectory&gt;PreserveNewest&lt;/CopyToPublishDirectory&gt;\n      &lt;ExcludeFromSingleFile&gt;true&lt;/ExcludeFromSingleFile&gt;\n    &lt;/ResolvedFileToPublish&gt;\n  &lt;/ItemGroup&gt;\n&lt;/Target&gt;</code>\n        </deckgo-highlight-code>\n      \n<p>To summarise what's happening here, when building in debug mode we are continuing to use the <code>npm run build</code> command to create a production build and the spa files get stored in the build folder <code>$(SpaRoot)build\\**</code>. The output looks like this:</p>\n<ul>\n<li>\n<p>bin</p>\n<ul>\n<li>Release</li>\n<li>\n<p>publish</p>\n<ul>\n<li>ClientApp</li>\n<li>build\n-spa files go here!   </li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>However in release mode we now create two versions of the spa (one for each environment) using out new npm environment builds, <code>npm run build:staging</code> and  <code>npm run build:production</code>. The builds also get moved to their corresponding folders.</p>\n<ul>\n<li>\n<p>bin</p>\n<ul>\n<li>Release</li>\n<li>\n<p>publish</p>\n<ul>\n<li>ClientApp</li>\n<li>\n<p>staging</p>\n<ul>\n<li>staging spa files go here!</li>\n</ul>\n</li>\n<li>\n<p>production</p>\n<ul>\n<li>production spa files go here!</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>Once thats setup you can test it out with <code>dotnet publish --configuration Release</code>, the build output should look something like this,</p>\n<p><img src=\"//images.ctfassets.net/wjg1udsw901v/6gBCaZH5bJ6vaNW2wf8QPD/7b1fcf59b5a716760ebf49c95aaaab85/BuildExample.png\" alt=\"build-output-spa\"></p>\n<h2 id=\"modifying-your-startupcs\" style=\"position:relative;\"><a href=\"#modifying-your-startupcs\" aria-label=\"modifying your startupcs permalink\" class=\"auto-link-header before\"><svg aria-hidden=\"true\" height=\"40\" width=\"40\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Modifying your startup.cs</h2>\n<p>The final step is to modify your Startup.cs file to switch out which spa to use based on the environment variable,</p>\n\n        <deckgo-highlight-code   terminal=\"carbon\" line-numbers=\"true\" >\n          <code slot=\"code\">services.AddSpaStaticFiles(configuration =&gt; configuration.RootPath = WebHostEnvironment.IsDevelopment()\n                ? &quot;ClientApp/build&quot;\n                : $&quot;ClientApp/{WebHostEnvironment.EnvironmentName}&quot;);</code>\n        </deckgo-highlight-code>\n      \n<h1 id=\"how-to-deploy-\" style=\"position:relative;\"><a href=\"#how-to-deploy-\" aria-label=\"how to deploy  permalink\" class=\"auto-link-header before\"><svg aria-hidden=\"true\" height=\"40\" width=\"40\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>How to deploy üöÄ</h1>\n<p>Deployment is now a simple case of running <code>dotnet publish --configuration Release</code>, once the published artefacts are deployed the app can now take its environment and run the appropriate spa. Build once and deploy anywhere!</p>"}}},"related":{"edges":[{"node":{"title":".NET & GRPC What they forgot to tell you","slug":"dotnet-grpc-forgot-to-tell-you","hero":{"file":{"url":"//images.ctfassets.net/wjg1udsw901v/5m1MwxccFfmDxkLKcq3dBt/b54fc31b09d0a266a3d8cd5082839976/grpc-logojpg.jpg"},"title":"GRPC Logo"}}},{"node":{"title":"Creating my dream tech blog with GatsbyJS","slug":"gatsby-tech-blog-starter","hero":{"file":{"url":"//images.ctfassets.net/wjg1udsw901v/6hjsGXkoyitmyiEuBdeTP2/c77e74af9235ac775f18836e2de07cac/gatsby-logo.jpg"},"title":"Gatsby JS"}}}]}},"pageContext":{"slug":"aspnet-core-react-spa-adding-environments","tags":["react","spa","asp.net","dotnet core","environments","env-cmd","shx","template","msbuild",".env"]}}}